# 二分查找

思想：首先，假设表中元素是按升序排列，将表中间位置记录的[关键字](https://baike.baidu.com/item/关键字)与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置[记录](https://baike.baidu.com/item/记录/1837758)将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的[记录](https://baike.baidu.com/item/记录/1837758)，使查找成功，或直到子表不存在为止，此时查找不成功。



## 1.[旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

```
示例 1：
输入：[3,4,5,1,2]
输出：1

示例 2：
输入：[2,2,2,0,1]
输出：0
```

**解题思路：**

1. 初始化左右两个指针
2. 对于旋转数组
   1. 若`numbers[mid] > numbers[right]`则分界点在`[mid+1,right]`之中，令`left = mid + 1`
   2. 若`numbers[mid] < numbers[right]`则分界点在`[left,mid]`之中，令`right = mid`
   3. 若`numbers[mid] = numbers[right]`，此时无法判断在那个区间中，则右指针自减。
3. 返回`numbers[left]`

```js
/**
 * @param {number[]} numbers
 * @return {number}
 */
var minArray = function(numbers) {
    let left = 0,right = numbers.length - 1;
    if(right === 0){
        return numbers[0];
    }
    while(left < right){
        let mid = Math.floor((left + right) >> 1);
        if(numbers[mid] > numbers[right]){
            left = mid + 1;
        }else if(numbers[mid] < numbers[right]){
            right = mid;
        }else {
            right--;
        }
    }
    return numbers[left];
};
```



## 2.[在排序数组中查找数字](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

统计一个数字在排序数组中出现的次数。

```
示例 1:
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2

示例 2:
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0

提示：
0 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
nums 是一个非递减数组
-10^9 <= target <= 10^9
```

**解题思路：**

二分查找到当前数字位置，同时向前向后遍历相同的数字即可

```js
var search = function(nums, target) {
      function mathRight(target) {
        let j = nums.length-1;
        let i = 0;
        while(i<=j) {
        let mid =  parseInt((i+j)/2);
        if(nums[mid]<=target) i = mid + 1;
        else j = mid - 1;
        }
        return i;
    }
    let right = mathRight(target);
    let left = mathRight(target - 1);
    return right - left;
};
```

