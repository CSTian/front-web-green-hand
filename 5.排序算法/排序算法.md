# 排序算法

## 1.冒泡排序

基本思想：比较两个记录键值的大小，如果这两个记录键值的大小出现逆序，则交换这两个记录



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/31/17268eba8157dbde~tplv-t2oaga2asx-watermark.awebp)

```js
function bubbleSort(arr){
  for(let i = 0; i < arr.length;i++){
    for(let j = i  ; j > 0 ;j --){
      if(arr[j] < arr[j - 1]){
        [arr[j],arr[j - 1]] = [arr[j - 1],arr[j]];
      }
    }
  }
  return arr;
}
```



## 2.快速排序

基本思想：在n个记录中取某一个记录的键值为标准，通常取第一个记录键值为基准，通过一趟排序将待排的记录分为小于或等于这个键值的两个独立的部分，这是一部分的记录键值均比另一部分记录的键值小，然后，对这两部分记录继续分别进行快速排序，以达到整个序列有序。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/31/17268eba844a4e72~tplv-t2oaga2asx-watermark.awebp )

```js
function quickSort(arr){
  if(arr.length <= 1) return arr;
  let right = [],left = [], keys = arr.shift();
  for(let value of arr){
    if(value > keys){
      right.push(value);
    }else{
      left.push(value);
    }
  }
  return quickSort(left).concat(keys,quickSort(right));
}
```



## 3.插入排序

第i（i大于等于1）个记录进行插入操作时，R1、 R2，...，是排好序的有序数列，取出第i个元素，在序列中找到一个合适的位置并将她插入到该位置上即可。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/31/17268eba8b4d9ada~tplv-t2oaga2asx-watermark.awebp)

```js
function insertSort(arr){
  for(let i = 1; i < arr.length;i++){
    let j = i - 1;
    if(arr[i] < arr[j]){
      let temp = arr[i];
      while(j >= 0 && temp < arr[j]){
        arr[j + 1] = arr[j];
        j--;
      }
      arr[j + 1] = temp;
    }
  }
  return arr;
}
```



## 4.希尔排序

算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/31/17268eba8b57523b~tplv-t2oaga2asx-watermark.awebp)

```js
function hillSort(arr){
    let len = arr.length;
    for(let gap = parseInt(len >> 1);gap >= 1;gap = parseInt(gap >> 1)){
        for(let i = gap;i < len;i++){
            if(arr[i] < arr[i-gap]){
                let temp = arr[i];
                let j = i - gap;
                while(j >= 0 && arr[j] > temp){
                    arr[j+gap] = arr[j];
                    j -= gap;
                }
                arr[j+gap] = temp;
            }
        }
    }
    return arr;
}
```



## 5.选择排序

在第i次选择操作中，通过n-i次键值间比较，从n-i+1个记录中选出键值最小的记录，并和第i（1小于等于1小于等于n-1）个记录交换

```js
function selectSort(arr){
  for(let i = 0;i  < arr.length; i++){
    let min = Math.min(...arr.slice(i));
    let index = arr.indexOf(min);
    [arr[i],arr[index]] = [arr[index],arr[i]];
  }
  return arr;
}
```

```js
function selectSort(arr){
  for(let i = 0;i < arr.length - 1; i++){
    let min = number.MAX_VALUE;
    let index = -1;
    for(let j = i + 1;j < arr.length; j++){
      if(min > arr[j]){
        min = arr[j];
        index = j;
      }
      [arr[i],arr[index]] = [arr[index],arr[i]]
    }
  }
  return arr;
}
```



## 6.堆排序

**堆排序**（英语：Heapsort）是指利用[堆](https://baike.baidu.com/item/堆)这种数据结构所设计的一种[排序算法](https://baike.baidu.com/item/排序算法)。堆是一个近似[完全二叉树](https://baike.baidu.com/item/完全二叉树)的结构，并同时满足**堆积的性质**：即子结点的键值或索引总是小于（或者大于）它的父节点。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/31/17268ebaae3e1b54~tplv-t2oaga2asx-watermark.awebp)

```js
function adjustMaxHeap(heap,head,heapSize){
  let temp = heap[head];
  let child = head * 2 + 1;
  while(child < heapSize){
    if(child + 1 < heapSize && heap[child] < heap[child + 1]) child++;
    if(heap[head] < heap[child]){
      	heap[head] = heap[child];
      	head = child;
      	child = head * 2 + 1;
    }else break;
    heap[head] = temp;
  }
}

function buildHeap(heap){
    for(let i = (heap.length-1) >> 1;i >= 0;i--){
        adjustMaxHeap(heap,i,heap.length);
    }
}

function heapSort(arr){
    buildHeap(arr);
    for(let i = arr.length-1;i > 0;i--){
        [arr[i],arr[0]] = [arr[0],arr[i]];
        adjustMaxHeap(arr,0,i);
    }
    return arr;
}
```



## 7.归并排序

把一个有n个记录的无序文件看成是由n个长度为1的有序子文件组成的文件，然后进行两两归并

![](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png)

```js
// 融合两个有序数组，这里实际上是将数组 arr 分为两个数组
function mergeArray(arr, first, mid, last, temp) {
  let i = first; 
  let m = mid;
  let j = mid+1;
  let n = last;
  let k = 0;
  while(i<=m && j<=n) {
    if(arr[i] < arr[j]) {
      temp[k++] = arr[i++];
    } else {
      temp[k++] = arr[j++];
    }
  }
  while(i<=m) {
    temp[k++] = arr[i++];
  }
  while(j<=n) {
    temp[k++] = arr[j++];
  } 
  for(let l=0; l<k; l++) {
    arr[first+l] = temp[l];
  }
  return arr;
}
// 递归实现归并排序
function mergeSort(arr, first, last, temp) {
  if(first<last) {
    let mid = Math.floor((first+last)/2);
    mergeSort(arr, first, mid, temp);    // 左子数组有序
    mergeSort(arr, mid+1, last, temp);   // 右子数组有序
    arr = mergeArray(arr, first, mid, last, temp);  
  }
  return arr;
}

// example
let arr = [10, 3, 1, 5, 11, 2, 0, 6, 3];
let temp = new Array();
let SortedArr = mergeSort(arr, 0 ,arr.length-1, temp);
alert(SortedArr);
```

